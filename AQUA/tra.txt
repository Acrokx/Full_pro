Taller de investigaci√≥n 

üìù TypeScript y POO

1.	Punto 2. ¬øQu√© ventajas ofrece TypeScript para trabajar con Programaci√≥n Orientada a Objetos?
TypeScript mejora la programaci√≥n orientada a objetos (POO) ofreciendo tipado est√°tico para detectar errores temprano, mejorando la mantenibilidad y escalabilidad de los proyectos gracias a caracter√≠sticas como clases e interfaces que estructuran el c√≥digo. Adem√°s, el soport√© mejorado de herramientas como IntelliSense y el autocompletado en los IDEs aumentan la productividad del desarrollador, haciendo que el desarrollador de aplicaciones complejas sea m√°s eficiente y robusto.
Ventajas clave de TypeScript para POO
-	Tipado Est√°tico: permite definir tipos para variables, funciones y propiedades de clases, lo que ayuda a detectar errores en tiempo de compilaci√≥n, no en tiempo de ejecuci√≥n y a crear c√≥digo m√°s fiable.

-	Detecci√≥n temprana de errores: al especificar tipos, TypeScript atrapa errores relacionados con los tipos antes de que el c√≥digo llegue a producci√≥n, reduciendo as√≠ el bug y da fiabilidad.

-	Mejora la mantenibilidad: El uso de clases, interfaces y otras caracter√≠sticas POO en TypeScript crea c√≥digo mas claro, organizado y f√°cil de entender, especialmente en proyectos de gran escala.

-	Escalabilidad y Estructura: Las interfaces proporcionan ‚Äúcontratos‚Äù que definen la estructura de los objetos, lo que permite crear aplicaciones modulares y f√°ciles de escalar, adapt√°ndose bien a proyectos complejos.

-	Soporte de Herramientas: Las anotaciones de tipo permiten que las herramientas de los editores (IDE) ofrezcan funciones avanzadas como autocompletado, IntelliSense y refactorizaci√≥n, incrementando la productividad del desarrollador.

-	Legibilidad y auto documentaci√≥n: El c√≥digo con tipos es m√°s f√°cil de leer y comprender, funcionando con documentaci√≥n integrada que ayuda a los desarrolladores a entender como fluyen los datos en la aplicaci√≥n.

-	Compatibilidad con JavaScript: TypeScript es un super conjunto de JavaScript, lo que significa que cualquier c√≥digo JavaScript valido tambi√©n es c√≥digo TypeScript valido. Esto permite una migraci√≥n gradual de proyectos existentes.





2.	Punto 4. ¬øQu√© es un readonly y para qu√© se usa?
-	Un readonly es un modificador en programaci√≥n y un atributo en HTML que especifica que un valor no puede ser cambiado despu√©s de su inicializaci√≥n. Se utiliza para proteger la integridad de los datos al permitir que se les asigne un valor una vez, ya sea en su declaraci√≥n o dentro de un constructor, pero impidiendo cualquier reasignaci√≥n posterior. Esto es √∫til para asegurar que ciertas variables o campos no sean modificados, accidentalmente manteniendo la consistencia y la previsibilidad del c√≥digo o la interfaz.

Usos comunes:
‚Ä¢	Programaci√≥n (C#, TypeScript, etc.):
Para declarar variables o campos que solo pueden asignarse una vez.
‚Ä¢	Desarrollo Web (HTML):
El atributo readonly en elementos <input> impide que el usuario modifique el valor de un campo de entrada.
‚Ä¢	Bases de Datos:
La cl√°usula FOR READ ONLY puede hacer que una tabla o cursor resultante no sea modificable.
3.	Punto 6. ¬øQu√© son los constructores y para qu√© sirven?
-	En la programaci√≥n orientada a objetos (POO) con TypeScript, un constructor es un m√©todo especial que se llama autom√°ticamente al crear una nueva instancia (un objeto) de una clase. Su funci√≥n principal es inicializar las propiedades del objeto, estableciendo su estado inicial para que est√© listo para usarse. Los constructores son fundamentales para crear y configurar objetos de forma organizada, ahorrando l√≠neas de c√≥digo y proporcionando un mecanismo para definir los valores requeridos de un objeto al instante de su creaci√≥n.

¬øPara qu√© sirven los constructores en TypeScript?

-	Inicializar propiedades:
Establecen los valores iniciales de los atributos de un objeto cuando este se crea.

-	Configurar objetos:
Permiten definir las caracter√≠sticas y comportamientos espec√≠ficos de un objeto al momento de su instanciaci√≥n.

-	Asegurar valores iniciales:
Garantizan que un objeto tenga los datos necesarios y en un estado v√°lido desde el principio.

-	Simplificar la creaci√≥n de objetos:
Hacen que el proceso de crear objetos sea m√°s eficiente al automatizar la asignaci√≥n de propiedades.



-	Promover la organizaci√≥n del c√≥digo:
-	Ayudan a mantener un c√≥digo m√°s limpio y f√°cil de mantener, ya que la inicializaci√≥n est√° centralizada en un √∫nico lugar.


4.	Punto 8. ¬øQu√© significa polimorfismo en el contexto de TS?
el polimorfismo es la capacidad de tratar objetos de diferentes clases como si fueran de una superclase com√∫n, permitiendo que cada uno responda a un mismo m√©todo de manera √∫nica. Esto significa que puedes invocar un mismo "mensaje" o m√©todo en objetos de tipos distintos y cada objeto lo ejecutar√° de forma espec√≠fica seg√∫n su propia implementaci√≥n, lo que resulta en un c√≥digo m√°s flexible, reutilizable y extensible.
¬øC√≥mo funciona?
‚Ä¢	Herencia:
El polimorfismo se logra com√∫nmente a trav√©s de la herencia, donde una subclase hereda propiedades y m√©todos de una superclase y los puede sobrescribir con su propia implementaci√≥n.
‚Ä¢	Interfaces:
Tambi√©n se puede implementar usando interfaces, que definen un conjunto de m√©todos que las clases deben implementar, permitiendo que objetos de diferentes clases cumplan con el mismo "contrato" de interfaz.
Ejemplo pr√°ctico
Imagina una superclase Animal con un m√©todo hacerSonido ().
‚Ä¢	Una clase Perro que hereda de Animal podr√≠a implementar hacerSonido () como "¬°Guau!".
‚Ä¢	Una clase Gato que tambi√©n hereda de Animal implementar√≠a hacerSonido () como "¬°Miau!".
Si tienes una funci√≥n que acepta un Animal, puedes pasarle un objeto Perro o un Gato, y la funci√≥n llamar√° al m√©todo hacerSonido () del objeto correcto en cada caso, sin necesidad de saber el tipo espec√≠fico en el momento de la llamada.
Beneficios en TypeScript
‚Ä¢	Reutilizaci√≥n de c√≥digo:
Puedes escribir funciones y clases que operen con objetos de una superclase o interfaz com√∫n, reutilizando la l√≥gica sin importar el tipo concreto.

‚Ä¢	Flexibilidad y extensibilidad:
Es f√°cil a√±adir nuevas clases que se adapten a la interfaz com√∫n, extendiendo la funcionalidad del sistema sin modificar el c√≥digo existente.
‚Ä¢	Abstracci√≥n:
El polimorfismo permite abstraer los detalles de implementaci√≥n, trabajando con una interfaz m√°s general para gestionar colecciones de objetos diversos.

Punto 10. ¬øQu√© es una interface en TS y en qu√© se diferencia de una clase abstracta?
una interface define la estructura y los contratos de los objetos, especificando qu√© propiedades y m√©todos deben tener, mientras que una clase abstracta es un modelo que no se puede instanciar directamente y puede contener tanto m√©todos abstractos como implementados, compartiendo c√≥digo y funcionalidades con sus clases derivadas. La diferencia principal es que las interfaces solo definen la "forma" y los contratos (qu√© hacer), sin proporcionar ninguna implementaci√≥n, mientras que las clases abstractas pueden ofrecer implementaciones concretas y comparten una jerarqu√≠a de herencia m√°s cercana.
Interface en TypeScript
‚Ä¢	Define un Contrato:
Una interface es un conjunto de declaraciones de m√©todos abstractos y propiedades que una clase debe seguir para ser considerada "de ese tipo".
‚Ä¢	Sin Implementaci√≥n:
Las interfaces solo describen la estructura (c√≥mo debe verse un objeto), no c√≥mo funcionar√°n sus miembros; no tienen implementaciones ni constructores.
‚Ä¢	Herencia M√∫ltiple:
Una clase puede implementar m√∫ltiples interfaces, lo que permite un dise√±o m√°s flexible y la conexi√≥n de clases sin relaci√≥n jer√°rquica.
‚Ä¢	Uso:
Se utiliza para definir tipos complejos, asegurar la consistencia y promover la abstracci√≥n.
Clase Abstracta
‚Ä¢	Modelo Base:
Es una clase que no puede ser instanciada directamente; existe solo como una base para otras clases.



‚Ä¢	M√©todos Concretos y Abstractos:
Puede incluir tanto m√©todos abstractos (sin implementaci√≥n) que deben ser implementados por las clases derivadas, como m√©todos concretos con su propio c√≥digo o estado.
‚Ä¢	Herencia Simple:
Las clases pueden heredar solo de una clase abstracta, a diferencia de las interfaces.
‚Ä¢	Compartir C√≥digo:
Permite compartir c√≥digo y funcionalidades comunes entre clases que est√°n relacionadas y pertenecen a una misma jerarqu√≠a.
Diferencias Clave
‚Ä¢	Implementaci√≥n:
Las clases abstractas pueden tener m√©todos con implementaciones (c√≥digo), mientras que las interfaces solo declaran m√©todos.
‚Ä¢	Estado:
Las clases abstractas pueden incluir estado (miembros y propiedades con valores), pero las interfaces no.
‚Ä¢	Prop√≥sito:
Las interfaces se usan para definir un contrato independiente para m√∫ltiples clases que pueden no tener nada en com√∫n, mientras que las clases abstractas conectan clases muy relacionadas.

Punto n√∫mero 12: Investigar y realizar la configuraci√≥n de TypeScript con Node JS y VS Code.
Para configurar TypeScript en un proyecto de Node.js con VS Code, primero instala Node.js y VS Code. Luego, en tu terminal, inicializa un proyecto de Node.js con npm init -y y instala el compilador de TypeScript globalmente con npm install -g typescript o localmente como dependencia de desarrollo con npm install --save-dev typescript. A continuaci√≥n, crea un archivo tsconfig.json ejecutando tsc --init para configurar las opciones del compilador y, finalmente, abre tu proyecto en VS Code, escribe c√≥digo TypeScript y usa el compilador (tsc) o el bot√≥n de compilaci√≥n (Ctrl+Shift+B) para generar el JavaScript y depurar tu aplicaci√≥n.
1. Requisitos Previos
‚Ä¢	Instala Node.js: Descarga e instala la versi√≥n adecuada de Node.js desde la p√°gina oficial para tu sistema operativo. Verifica la instalaci√≥n abriendo tu terminal y escribiendo node -v.
‚Ä¢	Instala Visual Studio Code: Si no lo tienes, desc√°rgalo desde Visual Studio Code e inst√°lalo.
2. Inicializa tu Proyecto Node.js
1.	Abre la terminal: en tu sistema operativo o directamente en VS Code (Ver > Nueva Terminal).
2.	Crea un directorio: para tu proyecto (si es necesario) y entra en √©l.
C√≥digo
mkdir mi-proyecto-ts
    cd mi-proyecto-ts
1.	Inicializa el proyecto: con npm init y acepta los valores por defecto con la opci√≥n -y.
C√≥digo
npm init -y
3. Instala el Compilador de TypeScript
1.	Instala TypeScript: como una dependencia de desarrollo:
C√≥digo
npm install --save-dev typescript
Esto agrega el compilador tsc a tu proyecto.
4. Crea el Archivo de Configuraci√≥n de TypeScript (tsconfig.json)
1.	Genera un archivo tsconfig.json: En la ra√≠z de tu proyecto, ejecuta el comando tsc --init. Esto crea el archivo tsconfig.json, que contiene todas las opciones de configuraci√≥n del compilador de TypeScript.
C√≥digo
npx tsc --init
5. Escribe y Compila tu C√≥digo TypeScript
1.	Crea un archivo TypeScript: Por ejemplo, src/index.ts.
2.	Escribe tu c√≥digo: Define una funci√≥n o una variable en TypeScript.

TypeScript
// src/index.ts
    function saludar(nombre: string) {
      console.log(`Hola, ${nombre}!`);
    }

    saludar("Mundo");
1.	Compila el c√≥digo:
o	Desde la terminal: Ejecuta el comando npx tsc para compilar todos los archivos .ts a .js. Los archivos JavaScript se generar√°n en un directorio llamado dist por defecto (puedes cambiar esto en tsconfig.json).
o	Desde VS Code: Presiona Ctrl+Shift+B (Windows/Linux) o Cmd+Shift+B (macOS) para que VS Code compile el proyecto usando el archivo tsconfig.json que configuraste.
6. Ejecuta tu Aplicaci√≥n Node.js
1.	Ejecuta el archivo JavaScript generado: con Node.js:
C√≥digo
node dist/index.js
Ver√°s la salida del c√≥digo compilado.
7. Configura la Depuraci√≥n (Opcional)
1.	Abre el panel de depuraci√≥n: en VS Code (icono del panel de depuraci√≥n en la barra lateral).
2.	Crea un archivo de configuraci√≥n de lanzamiento (launch.json): Haz clic en "create a launch.json file" y selecciona "Node.js" como entorno.
3.	Configura el punto de entrada: En el archivo launch.json, aseg√∫rate de que la opci√≥n program apunte a tu archivo JavaScript de salida (ej. "${workspaceFolder}/dist/index.js").






